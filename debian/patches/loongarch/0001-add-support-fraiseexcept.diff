From 5f89666a8ea0c8cbbd342cc8a6bc90d1a0a39482 Mon Sep 17 00:00:00 2001
From: chenglulu <chenglulu@loongson.cn>
Date: Mon, 18 Jan 2021 16:42:03 +0800
Subject: [PATCH 1/2] add support fraiseexcept

---
 sysdeps/loongarch/fpu/fraiseexcpt.c | 60 +++++++++++++++++++++++------
 1 file changed, 48 insertions(+), 12 deletions(-)

diff --git a/sysdeps/loongarch/fpu/fraiseexcpt.c b/sysdeps/loongarch/fpu/fraiseexcpt.c
index 56ad431662..2eec053abc 100644
--- a/sysdeps/loongarch/fpu/fraiseexcpt.c
+++ b/sysdeps/loongarch/fpu/fraiseexcpt.c
@@ -18,28 +18,64 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include <fenv.h>
-#include <fenv_libc.h>
 #include <fpu_control.h>
+#include <float.h>
 
 int
 __feraiseexcept (int excepts)
 {
-  fpu_control_t cw;
 
-  /* Get current state.  */
-  _FPU_GETCW (cw);
+  const float fp_zero = 0.0, fp_one = 1.0, fp_max = FLT_MAX,
+	fp_min = FLT_MIN, fp_1e32 = 1.0e32f, fp_two = 2.0,
+	fp_three = 3.0;
 
-  /* Set flag bits (which are accumulative), and *also* set the
-     cause bits. The setting of the cause bits is what actually causes
-     the hardware to generate the exception, if the corresponding enable
-     bit is set as well.  */
+  /* Raise exceptions represented by EXPECTS.  But we must raise only
+     one signal at a time.  It is important that if the overflow/underflow
+     exception and the inexact exception are given at the same time,
+     the overflow/underflow exception follows the inexact exception.*/
 
-  excepts &= FE_ALL_EXCEPT;
-  cw |= excepts | (excepts << CAUSE_SHIFT);
+  /* First: invalid exception.  */
+  if (FE_INVALID & excepts)
+    __asm__ __volatile__ (
+			  "fdiv.s $f0,%0,%0\n\t"
+			  :
+			  : "f" (fp_zero)
+			  :"$f0");
 
-  /* Set new state.  */
-  _FPU_SETCW (cw);
+  /* Next: division by zero.  */
+  if (FE_DIVBYZERO & excepts)
+    __asm__ __volatile__ (
+			  "fdiv.s $f0,%0,%1\n\t"
+			  :
+			  : "f" (fp_one), "f" (fp_zero)
+			  :"$f0");
 
+  /* Next: overflow.  */
+  if (FE_OVERFLOW & excepts)
+    /* There's no way to raise overflow without also raising inexact.  */
+    __asm__ __volatile__ (
+			  "fadd.s $f0,%0,%1\n\t"
+			  :
+			  : "f" (fp_max), "f" (fp_1e32)
+			  : "$f0");
+
+  /* Next: underflow.  */
+  if (FE_UNDERFLOW & excepts)
+    __asm__ __volatile__ (
+			  "fdiv.s $f0,%0,%1\n\t"
+			  :
+			  : "f" (fp_min), "f" (fp_three)
+			  : "$f0");
+
+  /* Last: inexact.  */
+  if (FE_INEXACT & excepts)
+    __asm__ __volatile__ (
+			  "fdiv.s $f0, %0, %1\n\t"
+			  :
+			  : "f" (fp_two), "f" (fp_three)
+			  : "$f0");
+
+  /* Success.  */
   return 0;
 }
 
-- 
2.27.0

